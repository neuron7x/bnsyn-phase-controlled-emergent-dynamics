from __future__ import annotations

import importlib
import json
import subprocess
from pathlib import Path
from typing import Any

from scripts.ci_policy import _load_yaml

REPO_ROOT = Path(__file__).resolve().parents[1]
ARTIFACT_ROOT = REPO_ROOT / "artifacts" / "de_tf"
LOG_DIR = ARTIFACT_ROOT / "logs"
QUALITY_DIR = ARTIFACT_ROOT / "quality"
RIC_DIR = ARTIFACT_ROOT / "ric"
POLICY_PATH = REPO_ROOT / ".github" / "ci_policy.yml"


def _run(cmd: list[str], gate: str) -> tuple[int, str, str]:
    proc = subprocess.run(cmd, capture_output=True, text=True, cwd=REPO_ROOT, check=False)
    payload = {
        "gate": gate,
        "cmd": cmd,
        "returncode": proc.returncode,
        "stdout": proc.stdout,
        "stderr": proc.stderr,
    }
    (LOG_DIR / f"{gate}.json").write_text(json.dumps(payload, indent=2, sort_keys=True) + "\n", encoding="utf-8")
    return proc.returncode, proc.stdout, proc.stderr


def _check_required_modules(policy: dict[str, Any]) -> list[str]:
    failures: list[str] = []
    p0 = set(policy["tiers"]["P0"])
    for name, tool in policy["tools"].items():
        if name not in p0:
            continue
        module = tool.get("module")
        if not module:
            failures.append(f"missing module name for {name}")
            continue
        try:
            importlib.import_module(str(module).replace("-", "_"))
        except ModuleNotFoundError:
            failures.append(f"missing module: {module}")
    return failures


def main() -> int:
    LOG_DIR.mkdir(parents=True, exist_ok=True)
    QUALITY_DIR.mkdir(parents=True, exist_ok=True)
    RIC_DIR.mkdir(parents=True, exist_ok=True)

    policy = _load_yaml(POLICY_PATH)
    gates = list(policy["tiers"]["P0"])
    results: list[dict[str, Any]] = []
    contradictions: list[str] = []

    module_failures = _check_required_modules(policy)
    if module_failures:
        contradictions.extend(module_failures)

    gate_cmds: dict[str, list[str]] = {
        "workflow_lint": ["python", "-m", "pytest", "tests/test_actions_pinned.py", "-q"],
        "toolchain_pin": ["python", "-m", "pip", "install", "--upgrade", "pip==26.0"],
        "install_repro": ["python", "-m", "scripts.ci_policy"],
        "ruff": ["python", "-m", "ruff", "check", "."],
        "mypy": ["python", "-m", "mypy", "src", "--strict", "--config-file", "pyproject.toml"],
        "pytest": ["python", "-m", "pytest", "-m", "not (validation or property)", "-q"],
        "build": ["python", "-m", "build"],
        "security_secrets": ["python", "-m", "scripts.ensure_gitleaks", "detect", "--redact", "--source=."],
        "security_deps": ["python", "-m", "pip_audit"],
        "required_checks_contract": ["python", "-m", "pytest", "tests/test_required_checks_manifest.py", "-q"],
    }

    for gate in gates:
        cmd = gate_cmds.get(gate)
        if cmd is None:
            contradictions.append(f"gate without command: {gate}")
            results.append({"gate": gate, "status": "fail", "reason": "missing command"})
            continue
        code, _, _ = _run(cmd, gate)
        status = "pass" if code == 0 else "fail"
        if status == "fail":
            contradictions.append(f"gate_failed:{gate}")
        results.append({"gate": gate, "status": status, "returncode": code})

    contradictions_payload = {"count": len(contradictions), "contradictions": sorted(contradictions)}
    (RIC_DIR / "contradictions.json").write_text(
        json.dumps(contradictions_payload, indent=2, sort_keys=True) + "\n", encoding="utf-8"
    )
    (RIC_DIR / "ric_report.md").write_text(
        "# RIC Report\n\n"
        f"- Contradictions: {len(contradictions)}\n",
        encoding="utf-8",
    )

    verdict = "PASS" if not contradictions and all(r["status"] == "pass" for r in results) else "FAIL"
    quality = {
        "protocol": policy["protocol"],
        "verdict": verdict,
        "contradictions": len(contradictions),
        "gates": results,
    }
    (QUALITY_DIR / "quality.json").write_text(
        json.dumps(quality, indent=2, sort_keys=True) + "\n", encoding="utf-8"
    )
    (QUALITY_DIR / "EVIDENCE_INDEX.md").write_text(
        "# Evidence Index\n\nGenerated by `python -m scripts.ci_gate_runner`.\n",
        encoding="utf-8",
    )

    print(json.dumps({"verdict": verdict, "contradictions": len(contradictions)}))
    return 0 if verdict == "PASS" else 1


if __name__ == "__main__":
    raise SystemExit(main())
