"""Deterministically discover BN-Syn public surfaces and emit markdown."""

from __future__ import annotations

import ast
import tomllib
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
OUT = ROOT / "docs" / "PROJECT_SURFACES.md"


def _load_pyproject() -> dict:
    return tomllib.loads((ROOT / "pyproject.toml").read_text(encoding="utf-8"))


def _discover_cli() -> list[tuple[str, str, str, str]]:
    scripts = _load_pyproject().get("project", {}).get("scripts", {})
    rows: list[tuple[str, str, str, str]] = []
    for name, target in sorted(scripts.items()):
        rows.append((f"CLI:{name}", "stable", f"pyproject.toml::{name}", target))
    return rows


def _discover_python_exports() -> list[tuple[str, str, str, str]]:
    init_path = ROOT / "src" / "bnsyn" / "__init__.py"
    tree = ast.parse(init_path.read_text(encoding="utf-8"))
    exports: list[str] = []
    for node in tree.body:
        if isinstance(node, ast.Assign):
            for target in node.targets:
                if isinstance(target, ast.Name) and target.id == "__all__":
                    if isinstance(node.value, (ast.List, ast.Tuple)):
                        for item in node.value.elts:
                            if isinstance(item, ast.Constant) and isinstance(item.value, str):
                                exports.append(item.value)
    rows: list[tuple[str, str, str, str]] = []
    for symbol in sorted(exports):
        label = "experimental" if symbol == "__version__" else "internal"
        rows.append((f"Python API:bnsyn.{symbol}", label, "src/bnsyn/__init__.py", "Exported in __all__"))
    return rows


def _discover_schemas() -> list[tuple[str, str, str, str]]:
    rows: list[tuple[str, str, str, str]] = []
    for schema in sorted((ROOT / "schemas").glob("*.json")):
        rows.append((f"Schema:{schema.name}", "stable", str(schema.relative_to(ROOT)), "JSON Schema artifact contract"))
    return rows


def _discover_canonical_docs() -> list[tuple[str, str, str, str]]:
    rows: list[tuple[str, str, str, str]] = []
    scan_files = [ROOT / "README.md", ROOT / "docs" / "START_HERE.md", ROOT / "docs" / "TESTING.md"]
    for path in scan_files:
        text = path.read_text(encoding="utf-8")
        if "canonical" in text.lower():
            rows.append((f"Doc Surface:{path.relative_to(ROOT)}", "stable", str(path.relative_to(ROOT)), "Contains canonical usage/gate guidance"))
    return rows


def main() -> int:
    rows = _discover_cli() + _discover_python_exports() + _discover_schemas() + _discover_canonical_docs()
    lines = [
        "# Project Public Surfaces (discovered)",
        "",
        "Generated by `python -m scripts.discover_public_surfaces`.",
        "",
        "## Method",
        "- CLI discovered from `pyproject.toml [project.scripts]`.",
        "- Public Python API discovered from `src/bnsyn/__init__.py::__all__`.",
        "- Schemas discovered from `schemas/*.json`.",
        "- Canonical usage docs discovered by scanning `README.md`, `docs/START_HERE.md`, `docs/TESTING.md` for `canonical` tokens.",
        "",
        "## Surfaces",
        "| surface | stability | source | notes |",
        "|---|---|---|---|",
    ]
    for surface, stability, source, notes in rows:
        lines.append(f"| `{surface}` | `{stability}` | `{source}` | {notes} |")
    lines += [
        "",
        "## Exclusions",
        "- Implicit module-level call paths outside `__all__` are excluded to avoid over-claiming API stability.",
        "- External links are not treated as enforceable public surfaces.",
    ]
    OUT.write_text("\n".join(lines) + "\n", encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
