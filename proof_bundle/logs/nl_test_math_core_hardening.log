     1	from __future__ import annotations
     2	
     3	import math
     4	
     5	import numpy as np
     6	import pytest
     7	
     8	from bnsyn.numerics.integrators import euler_step, exp_decay_step, rk2_step
     9	from bnsyn.sim.network import run_simulation
    10	from tests.tolerances import DT_INVARIANCE_ATOL, DT_INVARIANCE_RTOL
    11	
    12	
    13	@pytest.mark.smoke
    14	def test_smoke_summary_metrics_are_finite() -> None:
    15	    """Zero NaN/Inf on canonical smoke path per SPEC P2-11 summary metrics."""
    16	    metrics = run_simulation(steps=200, dt_ms=0.1, seed=7, N=60)
    17	    assert all(math.isfinite(v) for v in metrics.values())
    18	
    19	
    20	@pytest.mark.smoke
    21	def test_dt_halving_bounded_deviation_policy() -> None:
    22	    """dt-vs-dt/2 bounded check from existing SPEC P2-8/P2-11 CI strategy.
    23	
    24	    Tolerance rationale: simulator includes stochastic Poisson drive and threshold dynamics,
    25	    so short-run observed order is not strict O(dt^p); we enforce conservative bounded
    26	    relative/absolute drift using existing repository tolerances.
    27	    """
    28	    m_dt = run_simulation(steps=800, dt_ms=0.1, seed=123, N=100)
    29	    m_half = run_simulation(steps=1600, dt_ms=0.05, seed=123, N=100)
    30	
    31	    rel_rate = abs(m_dt["rate_mean_hz"] - m_half["rate_mean_hz"]) / max(m_half["rate_mean_hz"], 1e-6)
    32	    abs_sigma = abs(m_dt["sigma_mean"] - m_half["sigma_mean"])
    33	    assert rel_rate < DT_INVARIANCE_RTOL
    34	    assert abs_sigma < DT_INVARIANCE_ATOL
    35	
    36	
    37	def test_integrators_reject_invalid_dt_tau() -> None:
    38	    x = np.array([1.0], dtype=np.float64)
    39	
    40	    with pytest.raises(ValueError, match="dt must be a finite positive value"):
    41	        _ = euler_step(x, 0.0, lambda y: -y)
    42	
    43	    with pytest.raises(ValueError, match="dt must be a finite positive value"):
    44	        _ = rk2_step(x, float("nan"), lambda y: -y)
    45	
    46	    with pytest.raises(ValueError, match="dt must be a finite non-negative value"):
    47	        _ = exp_decay_step(x, -0.1, tau=2.0)
    48	
    49	    with pytest.raises(ValueError, match="tau must be positive"):
    50	        _ = exp_decay_step(x, 0.1, tau=0.0)
    51	
    52	
    53	def test_integrators_fail_closed_on_non_finite_derivatives() -> None:
    54	    x = np.array([1.0], dtype=np.float64)
    55	
    56	    with pytest.raises(ValueError, match="euler_step produced non-finite values"):
    57	        _ = euler_step(x, 0.1, lambda _y: np.array([np.inf], dtype=np.float64))
    58	
    59	    with pytest.raises(ValueError, match="rk2_step produced non-finite values"):
    60	        _ = rk2_step(x, 0.1, lambda _y: np.array([np.nan], dtype=np.float64))
