$ sed criticality analysis
"""Criticality analysis utilities for branching and avalanche statistics.

Parameters
----------
None

Returns
-------
None

Notes
-----
Provides deterministic estimators used to evaluate criticality metrics.

References
----------
docs/SPEC.md#P0-4
docs/SSOT.md
"""

from __future__ import annotations

from dataclasses import dataclass

import numpy as np


@dataclass(frozen=True)
class PowerLawFit:
    """Continuous power-law fit parameters.

    Parameters
    ----------
    alpha : float
        Power-law exponent.
    xmin : float
        Lower cutoff used in the fit.

    Notes
    -----
    Parameters correspond to the continuous MLE fit used for avalanche analysis.

    References
    ----------
    docs/SPEC.md#P0-4
    """

    alpha: float
    xmin: float


def mr_branching_ratio(activity: np.ndarray, max_lag: int = 5) -> float:
    """Estimate branching ratio using a multistep regression approach.

    Parameters
    ----------
    activity : np.ndarray
        1D activity counts per timestep (non-negative).
    max_lag : int, optional
        Maximum lag for multi-step regression.

    Returns
    -------
    float
        Mean branching ratio estimate across valid lags.

    Raises
    ------
    ValueError
        If activity is not 1D, too short, or contains negative values.

    Notes
    -----
    For each lag k, estimate slope of A(t+k) vs A(t) via least squares, then
    infer sigma_k = slope ** (1/k). Returns the mean sigma_k across lags.

    References
    ----------
    docs/SPEC.md#P0-4
    """
    if activity.ndim != 1:
        raise ValueError("activity must be 1D")
    if len(activity) <= max_lag + 1:
        raise ValueError("activity length too short for max_lag")
    if np.any(activity < 0):
        raise ValueError("activity must be non-negative")

    sigma_estimates: list[float] = []
    for k in range(1, max_lag + 1):
        x = activity[:-k]
        y = activity[k:]
        denom = float(np.dot(x, x))
        if denom == 0.0:
            continue
        slope = float(np.dot(x, y) / denom)
        if slope <= 0.0:
            continue
        sigma_estimates.append(slope ** (1.0 / k))
    if not sigma_estimates:
        raise ValueError("unable to estimate branching ratio")
    return float(np.mean(sigma_estimates))


def fit_power_law_mle(data: np.ndarray, xmin: float) -> PowerLawFit:
    """Continuous power-law MLE fit for alpha with fixed xmin.

    Parameters
    ----------
    data : np.ndarray
        1D sample data for the fit.
    xmin : float
        Lower cutoff for the power-law fit.

    Returns
    -------
    PowerLawFit
        Fitted power-law parameters.

    Raises
    ------
    ValueError
        If data are not 1D, xmin is invalid, or samples are out of range.

    Notes
    -----
    Uses the continuous maximum-likelihood estimator for alpha.

    References
    ----------
    docs/SPEC.md#P0-4
    """
    if data.ndim != 1:
        raise ValueError("data must be 1D")
    if xmin <= 0:
        raise ValueError("xmin must be positive")
    if np.any(data < xmin):
        raise ValueError("data contains values below xmin")
    logs = np.log(data / xmin)
    if np.all(logs == 0):
        raise ValueError("data must include values above xmin for power-law fit")
    alpha = 1.0 + len(data) / float(np.sum(logs))
    return PowerLawFit(alpha=float(alpha), xmin=float(xmin))
$ sed phase_transition
"""Phase transition detection for criticality analysis.

Parameters
----------
None

Returns
-------
None

Notes
-----
Implements phase transition detector for tracking critical state transitions.

References
----------
docs/SPEC.md#P0-4
"""

from __future__ import annotations

from collections import deque
from dataclasses import dataclass
from enum import Enum
from typing import Callable


class CriticalPhase(Enum):
    """Critical phase enumeration.

    Attributes
    ----------
    SUBCRITICAL : int
        Below critical point (sigma < 0.95)
    CRITICAL : int
        At critical point (0.95 <= sigma <= 1.05)
    SUPERCRITICAL : int
        Above critical point (sigma > 1.05)
    UNKNOWN : int
        Phase not yet determined
    """

    SUBCRITICAL = 0
    CRITICAL = 1
    SUPERCRITICAL = 2
    UNKNOWN = 3


@dataclass(frozen=True)
class PhaseTransition:
    """Record of a phase transition event.

    Parameters
    ----------
    step : int
        Simulation step when transition occurred.
    from_phase : CriticalPhase
        Phase before transition.
    to_phase : CriticalPhase
        Phase after transition.
    sigma_before : float
        Sigma value before transition.
    sigma_after : float
        Sigma value after transition.
    sharpness : float
        Transition sharpness (absolute difference in sigma).
    """

    step: int
    from_phase: CriticalPhase
    to_phase: CriticalPhase
    sigma_before: float
    sigma_after: float
    sharpness: float


class PhaseTransitionDetector:
    """Detector for phase transitions in criticality.

    Parameters
    ----------
    subcritical_threshold : float, optional
        Upper bound for subcritical phase (default: 0.95).
    supercritical_threshold : float, optional
        Lower bound for supercritical phase (default: 1.05).
    history_size : int, optional
        Maximum history size for sigma tracking (default: 200).

    Notes
    -----
    Tracks sigma history in a deque with maximum size to detect transitions.

    References
    ----------
    docs/SPEC.md#P0-4
    """

    def __init__(
        self,
        subcritical_threshold: float = 0.95,
        supercritical_threshold: float = 1.05,
        history_size: int = 200,
    ):
        """Initialize transition detector thresholds and bounded histories.

        Parameters
        ----------
        subcritical_threshold : float, optional
            Upper sigma boundary for subcritical classification.
        supercritical_threshold : float, optional
            Lower sigma boundary for supercritical classification.
        history_size : int, optional
            Maximum number of sigma/phase observations retained.

        Raises
        ------
        ValueError
            If thresholds are unordered or ``history_size`` is non-positive.

        Notes
        -----
        Maintains fixed-size deques for deterministic memory bounds and
        transition sharpness calculations over recent observations.
        """
        if subcritical_threshold >= supercritical_threshold:
            raise ValueError("subcritical_threshold must be less than supercritical_threshold")
        if history_size <= 0:
            raise ValueError("history_size must be positive")

        self.subcritical_threshold = subcritical_threshold
        self.supercritical_threshold = supercritical_threshold
        self.history_size = history_size

        self._sigma_history: deque[tuple[int, float]] = deque(maxlen=history_size)
        self._phase_history: deque[tuple[int, CriticalPhase]] = deque(maxlen=history_size)
        self._current_phase: CriticalPhase = CriticalPhase.UNKNOWN
        self._transitions: list[PhaseTransition] = []
        self._transition_callbacks: list[Callable[[PhaseTransition], None]] = []
        self._step_entered_phase: int = 0

    def _classify_phase(self, sigma: float) -> CriticalPhase:
        """Classify sigma value into a phase.

        Parameters
        ----------
        sigma : float
            Sigma value to classify.

        Returns
        -------
        CriticalPhase
            Classified phase.
        """
        if sigma < self.subcritical_threshold:
            return CriticalPhase.SUBCRITICAL
        elif sigma > self.supercritical_threshold:
            return CriticalPhase.SUPERCRITICAL
        else:
            return CriticalPhase.CRITICAL

    def observe(self, sigma: float, step: int) -> CriticalPhase | None:
        """Observe a sigma value and detect transitions.

        Parameters
        ----------
        sigma : float
            Current sigma value.
        step : int
            Current simulation step.

        Returns
        -------
        CriticalPhase | None
            New phase if transition occurred, None otherwise.

        Notes
        -----
        Updates internal state and triggers callbacks on transitions.
        """
        # classify current sigma
        new_phase = self._classify_phase(sigma)

        # record history
        self._sigma_history.append((step, sigma))
        self._phase_history.append((step, new_phase))

        # detect transition
        if new_phase != self._current_phase and self._current_phase != CriticalPhase.UNKNOWN:
            # get previous sigma
            sigma_before = self._sigma_history[-2][1] if len(self._sigma_history) >= 2 else sigma
            sharpness = abs(sigma - sigma_before)

            transition = PhaseTransition(
                step=step,
                from_phase=self._current_phase,
                to_phase=new_phase,
                sigma_before=sigma_before,
                sigma_after=sigma,
                sharpness=sharpness,
            )
            self._transitions.append(transition)

            # trigger callbacks
            for callback in self._transition_callbacks:
                callback(transition)

            # update current phase
            self._current_phase = new_phase
            self._step_entered_phase = step

            return new_phase

        # initialize or update current phase
        if self._current_phase == CriticalPhase.UNKNOWN:
            self._current_phase = new_phase
            self._step_entered_phase = step

        return None

    def on_transition(self, callback: Callable[[PhaseTransition], None]) -> None:
        """Register a callback for phase transitions.

        Parameters
        ----------
        callback : Callable[[PhaseTransition], None]
            Callback function receiving PhaseTransition.
        """
        self._transition_callbacks.append(callback)

    def current_phase(self) -> CriticalPhase:
        """Return current critical phase.

        Returns
        -------
        CriticalPhase
            Current phase.
        """
        return self._current_phase

    def sigma_derivative(self) -> float | None:
