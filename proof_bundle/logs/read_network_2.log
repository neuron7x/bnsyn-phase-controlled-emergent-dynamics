        # criticality estimation from population activity
        A_t = float(np.sum(spikes))
        A_t1 = float(np.sum(self.state.spiked))
        sigma = self.branch.update(A_t=max(A_t, 1.0), A_t1=max(A_t1, 1.0))
        self.gain = self.sigma_ctl.step(sigma)

        self._A_prev = A_t1

        return {
            "A_t": A_t,
            "A_t1": A_t1,
            "sigma": float(sigma),
            "gain": float(self.gain),
            "spike_rate_hz": float(A_t1 / N) / (dt / 1000.0),
        }

    def step_adaptive(
        self,
        *,
        atol: float = 1e-8,
        rtol: float = 1e-6,
        external_current_pA: NDArray[np.float64] | None = None,
    ) -> dict[str, float]:
        """Advance the network by one timestep using adaptive AdEx integration.

        Parameters
        ----------
        atol : float, optional
            Absolute tolerance for adaptive AdEx integration.
        rtol : float, optional
            Relative tolerance for adaptive AdEx integration.

        external_current_pA : NDArray[np.float64] | None, optional
            External current injection per neuron in pA. Shape must be (N,).
            If None, no external current injection is applied (default behavior).

        Returns
        -------
        dict[str, float]
            Dictionary of metrics including sigma, gain, and spike rate.

        Raises
        ------
        ValueError
            If external_current_pA shape does not match number of neurons.
        RuntimeError
            If voltage bounds are violated (numerical instability).

        Notes
        -----
        Uses adaptive AdEx integration while preserving criticality tracking.

        References
        ----------
        docs/SPEC.md#P2-11
        """
        N = self.np.N
        dt = self.dt_ms

        if external_current_pA is not None:
            if external_current_pA.shape != (N,):
                raise ValueError(
                    f"external_current_pA shape {external_current_pA.shape} "
                    f"does not match number of neurons ({N},)"
                )

        lam = self.np.ext_rate_hz * (dt / 1000.0)
        ext_spikes = self.rng.random(N) < lam
        incoming_ext = ext_spikes.astype(float) * self.np.ext_w_nS

        spikes = self.state.spiked
        spikes_E = spikes[: self.nE].astype(float)
        spikes_I = spikes[self.nE :].astype(float)

        if self._use_torch:
            if torch is None:
                raise RuntimeError("PyTorch not available. Install with: pip install torch")
            torch_module = cast(Any, torch)
            spikes_E_t = torch_module.as_tensor(
                spikes_E,
                dtype=torch_module.float64,
                device=self._torch_device,
            )
            spikes_I_t = torch_module.as_tensor(
                spikes_I,
                dtype=torch_module.float64,
                device=self._torch_device,
            )
            incoming_exc = torch_module.matmul(self._W_exc_t, spikes_E_t).cpu().numpy()
            incoming_inh = torch_module.matmul(self._W_inh_t, spikes_I_t).cpu().numpy()
        else:
            incoming_exc = self.W_exc.apply(np.asarray(spikes_E, dtype=np.float64))
            incoming_inh = self.W_inh.apply(np.asarray(spikes_I, dtype=np.float64))

        self.g_ampa += AMPA_FRACTION * incoming_exc + AMPA_FRACTION * incoming_ext
        self.g_nmda += NMDA_FRACTION * incoming_exc + NMDA_FRACTION * incoming_ext
        self.g_gabaa += incoming_inh

        self.g_ampa = exp_decay_step(self.g_ampa, dt, self.syn.tau_AMPA_ms)
        self.g_nmda = exp_decay_step(self.g_nmda, dt, self.syn.tau_NMDA_ms)
        self.g_gabaa = exp_decay_step(self.g_gabaa, dt, self.syn.tau_GABAA_ms)

        V = self.state.V_mV
        B = nmda_mg_block(V, self.syn.mg_mM)
        I_syn = (
            self.g_ampa * (V - self.syn.E_AMPA_mV)
            + self.g_nmda * B * (V - self.syn.E_NMDA_mV)
            + self.g_gabaa * (V - self.syn.E_GABAA_mV)
        )

        I_ext = self._I_ext_buffer
        I_ext.fill(0.0)
        I_ext += GAIN_CURRENT_SCALE_PA * (self.gain - 1.0)

        if external_current_pA is not None:
            I_ext += external_current_pA

        self.state = adex_step_adaptive(
            self.state,
            self.adex,
            dt,
            I_syn_pA=I_syn,
            I_ext_pA=I_ext,
            atol=atol,
            rtol=rtol,
        )

        self._raise_if_voltage_out_of_bounds()

        A_t = float(np.sum(spikes))
        A_t1 = float(np.sum(self.state.spiked))
        sigma = self.branch.update(A_t=max(A_t, 1.0), A_t1=max(A_t1, 1.0))
        self.gain = self.sigma_ctl.step(sigma)

        self._A_prev = A_t1

        return {
            "A_t": A_t,
            "A_t1": A_t1,
            "sigma": float(sigma),
            "gain": float(self.gain),
            "spike_rate_hz": float(A_t1 / N) / (dt / 1000.0),
        }

    def _raise_if_voltage_out_of_bounds(self) -> None:
        if (
            float(np.min(self.state.V_mV)) < self.np.V_min_mV
            or float(np.max(self.state.V_mV)) > self.np.V_max_mV
        ):
            raise RuntimeError("Voltage bounds violation (numerical instability)")


def run_simulation(
    steps: int,
    dt_ms: float,
    seed: int,
    N: int = 200,
    backend: Literal["reference", "accelerated"] = "reference",
    external_current_pA: float = 0.0,
) -> dict[str, float]:
    """Run a deterministic simulation and return summary metrics.

    Parameters
    ----------
    steps : int
        Number of simulation steps.
    dt_ms : float
        Timestep in milliseconds.
    seed : int
        RNG seed.
    N : int, optional
        Number of neurons.
    backend : Literal["reference", "accelerated"], optional
        Backend mode: 'reference' (default) or 'accelerated'.
    external_current_pA : float, optional
        Constant external current injection per neuron in picoamps.
        Default is 0.0 (no injection). Use positive values to increase
        network excitability and ensure spiking activity.

    Returns
    -------
    dict[str, float]
        Summary metrics with mean and standard deviation for sigma and firing rate.

    Notes
    -----
    Uses explicit seeding and validation to satisfy the determinism contract.
    External current injection can be used to ensure network activity for testing.

    References
    ----------
    docs/SPEC.md#P2-11
    docs/REPRODUCIBILITY.md
    """
    from bnsyn.rng import seed_all

    if not isinstance(steps, Integral):
        raise TypeError("steps must be a positive integer")
    if steps <= 0:
        raise ValueError("steps must be greater than 0")
    if not isinstance(external_current_pA, Real):
